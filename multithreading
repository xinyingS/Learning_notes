Reference from: https://www.udemy.com/multithreading-and-parallel-computing-in-java/


一、Course Architechture
    1. Basic multithreading
       (1) Process vs thread
       (2) Threads, runnables
       (3) Volatile, join(), notify()
       (4) Low and high level concurrency
    2. Complex problems
       (1) Library project
       (2) Dining philosophers problem
       (3) Simulation: mine sweeper
       (4) Conway's game of life
    3. Parellel Algorithm

二、
   1.
     Sequential

     multithreading  ->
     concurrency    -> at same time

   2.
     Thread join() -> waits for thread died (to finish it's task)

   3. Volatile -> slower -> threads to visit same area(RAM: Main memory)
      Cache  -> faster -> only one thread (located in it) can visit

   4. DeadLock vs LiveLock
      DeadLock in block state; LiveLock not in block state, threads communicate each other
      but they are too busy responding to each other to resume work.

   5. Synchronized

      public synchronized static void method1(){}  -> equal to lock the whole class,
      public synchronized static void method2(){}  -> no chance to execute same time

      //synchronized block
      |   public static void method1(){
              synchronized(className.class){
                  ...;
              }
          }
      |
          public static void method2(){
              synchronized(className.class){
                  ...;
              }
          }
          这种方法还是锁住同一个class.

      improve method:
      private Object lock1 = new Object();
      private Object lock2 = new Object();
      public static void method1(){
              synchronized(lock1){
                  ...;
              }
      }

      public static void method2(){
          synchronized(lock2){
              ...;
          }
      }

    6. wait() vs notify()
       (1) must same lock (same class)
       (2) notify() random wake up already wait() threads
       (3) if all, we should use notifyAll()

       Simply put, it depends on why your threads are waiting to be notified. Do you want to tell one of the waiting threads that something happened, or do you want to tell all of them at the same time?

       In some cases, all waiting threads can take useful action once the wait finishes. An example would be a set of threads waiting for a certain task to finish; once the task has finished,

       all waiting threads can continue with their business. In such a case you would use notifyAll() to wake up all waiting threads at the same time.

       Another case, for example mutually exclusive locking, only one of the waiting threads can do something useful after being notified (in this case acquire the lock). In such a case, you would rather use notify(). Properly implemented,

       you could use notifyAll() in this situation as well, but you would unnecessarily wake threads that can't do anything anyway.


    7. Locks
       (1) ReentrantLock -> implement the Lock interface.

           - it has the same behavior as the "synchronized approach"
           - of course it has some additional features

             new ReentrantLock(boolean fairnessParameter)
                 - fairness parameter: if it is set to be true --> the longest waiting thread will get the lock

                   fairness == false --> there is no access order.

              IMPORTANT : we have to use try- catch block when doing critical section
                              that may throw exceptions
                              ~ we call unlock() in the finally block.
                              (if we not unlock(), may be cause deadLock)

      (2) some resources need to be consistent.
          so synchronized or lock(), unlock() -> same function

          The advantage of lock() and unlock() -> we can put lock() and unlock() code anywhere we want.

    8. condition.await() && condition.signal() -> 用于ReentrantLock
     ->  wait()              notify()

       use:
       Lock lock = new ReentrantLock();
       Condition condition = lock.newCondition();

    9. Semaphores:
       Semaphores are variables or abstract data type that are used for controlling access to a common resource.
       It's a record of how many units of a particular resource are available... wait until a unit of the resource becomes available.

       (1)Counting Semaphore: allows an arbitrary resource count.
       (2)Binary Semaphore: Semaphores which are restricted to the values 0 and 1.

       eg:
       facebook server there are 10000 user want to download the same picture at the same time, so we must control the thread number.
       
