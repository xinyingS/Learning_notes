Reference from: https://www.udemy.com/multithreading-and-parallel-computing-in-java/


一、Course Architechture
    1. Basic multithreading
       (1) Process vs thread
       (2) Threads, runnables
       (3) Volatile, join(), notify()
       (4) Low and high level concurrency
    2. Complex problems
       (1) Library project
       (2) Dining philosophers problem
       (3) Simulation: mine sweeper
       (4) Conway's game of life
    3. Parellel Algorithm

二、
   1.
     Sequential

     multithreading  ->
     concurrency    -> at same time

   2.
     Thread join() -> waits for thread died (to finish it's task)

   3. Volatile -> slower -> threads to visit same area(RAM: Main memory)
      Cache  -> faster -> only one thread (located in it) can visit

   4. DeadLock vs LiveLock
      DeadLock in block state; LiveLock not in block state, threads communicate each other
      but they are too busy responding to each other to resume work.

   5. Synchronized

      public synchronized static void method1(){}  -> equal to lock the whole class,
      public synchronized static void method2(){}  -> no chance to execute same time

      //synchronized block
      |   public static void method1(){
              synchronized(className.class){
                  ...;
              }
          }
      |
          public static void method2(){
              synchronized(className.class){
                  ...;
              }
          }
          这种方法还是锁住同一个class.

      improve method:
      private Object lock1 = new Object();
      private Object lock2 = new Object();
      public static void method1(){
              synchronized(lock1){
                  ...;
              }
      }

      public static void method2(){
          synchronized(lock2){
              ...;
          }
      }

    6. wait() vs notify()
       (1) must same lock (same class)
       (2) notify() random wake up already wait() threads
       (3) if all, we should use notifyAll()
        
